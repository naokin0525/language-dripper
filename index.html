<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conlang Generator - 人工言語生成ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* For modern browsers */
        :root {
            --bg-color: #1a202c;
            --text-color: #e2e8f0;
            --panel-bg: #2d3748;
            --control-bg: #4a5568;
            --accent-color: #4299e1;
            --border-color: #4a5568;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 0.5rem;
            padding: 1.5rem;
        }

        details>summary {
            cursor: pointer;
            font-weight: 600;
            padding: 0.5rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
        }

        details>summary:hover {
            background-color: var(--control-bg);
        }

        details[open]>summary {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        input[type="text"],
        textarea,
        select,
        input[type="number"] {
            width: 100%;
            background-color: var(--control-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            padding: 0.5rem;
            color: var(--text-color);
        }

        textarea {
            min-height: 100px;
            font-family: "Menlo", "Monaco", monospace;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2b6cb0;
        }

        .btn-secondary {
            background-color: var(--control-bg);
        }

        .btn-secondary:hover {
            background-color: #718096;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
        }

        th {
            background-color: var(--control-bg);
        }
    </style>
</head>

<body class="p-4 lg:p-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl font-bold">Conlang Generator</h1>
        <p class="text-lg text-gray-400">インタラクティブな人工言語生成ツール</p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <!-- Left Column: Controls -->
        <div id="controls-panel" class="panel flex flex-col gap-6">
            <h2 class="text-2xl font-bold border-b border-gray-600 pb-2">コントロールパネル</h2>

            <!-- Phonology Section -->
            <details open>
                <summary class="text-xl">I. 音声・音韻論</summary>
                <div class="flex flex-col gap-4 pl-4 border-l border-gray-600">
                    <div>
                        <label for="consonants">子音 (IPA, スペース区切り)</label>
                        <textarea id="consonants">p t k b d g m n s z h r j w</textarea>
                        <div class="flex gap-2 mt-2">
                            <button class="btn btn-secondary text-sm" data-preset="japanese">日本語風</button>
                            <button class="btn btn-secondary text-sm" data-preset="english">英語風</button>
                            <button class="btn btn-secondary text-sm" data-preset="spanish">スペイン語風</button>
                        </div>
                    </div>
                    <div>
                        <label for="vowels">母音 (IPA, スペース区切り)</label>
                        <textarea id="vowels">a i u e o</textarea>
                    </div>
                    <div>
                        <label for="syllable-structure">音節構造 (カンマ区切り)</label>
                        <input type="text" id="syllable-structure" value="CV,V,CVC">
                    </div>
                    <!-- Tones Section -->
                    <div class="flex flex-col gap-2">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="tones-enabled">
                            <span>声調を有効化</span>
                        </label>
                        <div id="tones-controls" class="pl-6 hidden">
                            <label for="tones-count">声調の数 (2-9)</label>
                            <input type="range" id="tones-count" min="2" max="9" value="3" class="w-full">
                            <span id="tones-count-value" class="text-sm">3</span>
                        </div>
                    </div>
                    <!-- Phonological rules (simplified for this example) -->
                    <div>
                        <label>音韻変化ルール (例: n > m / _p)</label>
                        <div id="phonology-rules-list"></div>
                        <button id="add-phonology-rule" class="btn btn-secondary mt-2 text-sm">+ ルール追加</button>
                    </div>
                </div>
            </details>

            <!-- Lexicon Section -->
            <details open>
                <summary class="text-xl">II. 語彙</summary>
                <div class="flex flex-col gap-4 pl-4 border-l border-gray-600">
                    <div>
                        <label for="semantic-fields">意味分野 (カンマ区切り)</label>
                        <textarea id="semantic-fields">自然,動物,感情,行動,道具,社会,思考</textarea>
                    </div>
                    <div>
                        <label for="lexicon-size">生成する語根の数</label>
                        <input type="number" id="lexicon-size" value="100" min="10" max="1000" class="w-full">
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="loanwords-enabled">
                        <label for="loanwords-enabled">借用語をシミュレート</label>
                    </div>
                    <button id="generate-lexicon" class="btn btn-primary">語彙と文法を生成</button>
                </div>
            </details>

            <!-- Morphology & Syntax Section -->
            <details open>
                <summary class="text-xl">III. 形態論・統語論</summary>
                <div class="flex flex-col gap-4 pl-4 border-l border-gray-600">
                    <div>
                        <label for="word-order">基本語順</label>
                        <select id="word-order">
                            <option value="SOV" selected>SOV</option>
                            <option value="SVO">SVO</option>
                            <option value="VSO">VSO</option>
                            <option value="VOS">VOS</option>
                            <option value="OVS">OVS</option>
                            <option value="OSV">OSV</option>
                        </select>
                    </div>
                    <div>
                        <label>格標示</label>
                        <div class="flex gap-4 flex-wrap">
                            <label><input type="radio" name="case-marking" value="suffix" checked> 接尾辞</label>
                            <label><input type="radio" name="case-marking" value="prefix"> 接頭辞</label>
                            <label><input type="radio" name="case-marking" value="postposition"> 後置詞</label>
                            <label><input type="radio" name="case-marking" value="word-order"> 語順</label>
                        </div>
                    </div>
                    <div>
                        <label for="irregularity-rate">不規則性 (0-20%)</label>
                        <input type="range" id="irregularity-rate" min="0" max="20" value="5" class="w-full">
                        <span id="irregularity-rate-value" class="text-sm">5%</span>
                    </div>
                    <!-- Nominal Categories -->
                    <div>
                        <label>名詞の文法性</label>
                        <div class="flex gap-4">
                            <label><input type="radio" name="grammatical-gender" value="none" checked> なし</label>
                            <label><input type="radio" name="grammatical-gender" value="mf"> 男性/女性</label>
                            <label><input type="radio" name="grammatical-gender" value="mfn"> 男性/女性/中性</label>
                        </div>
                    </div>
                    <div>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="gender-agreement">
                            <span>性の一致を有効化</span>
                        </label>
                    </div>
                    <!-- Derivational Morphology (simplified) -->
                    <div>
                        <label>派生形態論 (例: -ness, un-)</label>
                        <div id="derivational-morphemes-list"></div>
                        <button id="add-morpheme" class="btn btn-secondary mt-2 text-sm">+ 接辞追加</button>
                    </div>
                </div>
            </details>
        </div>

        <!-- Right Column: Display -->
        <div id="display-panel" class="panel flex flex-col gap-6">
            <h2 class="text-2xl font-bold border-b border-gray-600 pb-2">ディスプレイパネル</h2>

            <div class="flex gap-2">
                <button id="export-json" class="btn btn-secondary">JSONでエクスポート</button>
                <button id="export-csv" class="btn btn-secondary">CSVでエクスポート</button>
            </div>

            <!-- Grammar Summary -->
            <div>
                <h3 class="text-xl font-semibold mb-2">文法概要</h3>
                <div id="grammar-summary" class="prose prose-invert text-gray-300"></div>
            </div>

            <!-- Example Sentences -->
            <div>
                <h3 class="text-xl font-semibold mb-2">例文</h3>
                <div id="example-sentences" class="bg-gray-800 p-4 rounded space-y-2"></div>
            </div>

            <!-- Lexicon -->
            <div>
                <h3 class="text-xl font-semibold mb-2">辞書</h3>
                <div class="overflow-auto max-h-96">
                    <table id="lexicon-table">
                        <thead>
                            <tr>
                                <th>IPA</th>
                                <th>ローマ字</th>
                                <th>品詞</th>
                                <th>意味</th>
                                <th>文法性</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. STATE MANAGEMENT ---
            // Centralized state object for the entire application
            const languageState = {
                phonology: {
                    consonants: [],
                    vowels: [],
                    syllableStructures: [],
                    phonologicalRules: [],
                    tones: {
                        enabled: false,
                        count: 3,
                    }
                },
                lexicon: {
                    semanticFields: [],
                    rootCount: 100,
                    loanwords: {
                        enabled: false,
                    }
                },
                morphoSyntax: {
                    wordOrder: 'SOV',
                    caseMarking: 'suffix',
                    irregularityRate: 0.05,
                    derivationalMorphemes: [],
                    grammaticalGender: 'none',
                    genderAgreement: false,
                },
                generated: {
                    dictionary: [],
                    grammarMarkers: null,
                }
            };

            // --- 2. DOM ELEMENT CACHE ---
            // Caching frequently accessed DOM elements for performance
            const UI = {
                controls: {
                    consonants: document.getElementById('consonants'),
                    vowels: document.getElementById('vowels'),
                    syllableStructure: document.getElementById('syllable-structure'),
                    tonesEnabled: document.getElementById('tones-enabled'),
                    tonesControls: document.getElementById('tones-controls'),
                    tonesCount: document.getElementById('tones-count'),
                    tonesCountValue: document.getElementById('tones-count-value'),
                    phonologyRulesList: document.getElementById('phonology-rules-list'),
                    addPhonologyRuleBtn: document.getElementById('add-phonology-rule'),
                    presetBtns: document.querySelectorAll('[data-preset]'),
                    semanticFields: document.getElementById('semantic-fields'),
                    lexiconSize: document.getElementById('lexicon-size'),
                    loanwordsEnabled: document.getElementById('loanwords-enabled'),
                    generateLexiconBtn: document.getElementById('generate-lexicon'),
                    wordOrder: document.getElementById('word-order'),
                    caseMarking: document.querySelectorAll('input[name="case-marking"]'),
                    grammaticalGender: document.querySelectorAll('input[name="grammatical-gender"]'),
                    genderAgreement: document.getElementById('gender-agreement'),
                    irregularityRate: document.getElementById('irregularity-rate'),
                    irregularityRateValue: document.getElementById('irregularity-rate-value'),
                    derivationalMorphemesList: document.getElementById('derivational-morphemes-list'),
                    addMorphemeBtn: document.getElementById('add-morpheme'),
                },
                display: {
                    grammarSummary: document.getElementById('grammar-summary'),
                    exampleSentences: document.getElementById('example-sentences'),
                    lexiconTableBody: document.querySelector('#lexicon-table tbody'),
                },
                export: {
                    jsonBtn: document.getElementById('export-json'),
                    csvBtn: document.getElementById('export-csv'),
                }
            };

            // --- 3. CORE LOGIC MODULES ---

            /**
             * Phonology Module: Handles sound systems and word generation.
             */
            const Phonology = {
                // Simple IPA to Romanization mapping (can be expanded)
                ipaToRomanMap: {
                    'p': 'p', 't': 't', 'k': 'k', 'b': 'b', 'd': 'd', 'g': 'g', 'm': 'm', 'n': 'n',
                    's': 's', 'z': 'z', 'h': 'h', 'r': 'r', 'j': 'y', 'w': 'w', 'a': 'a', 'i': 'i',
                    'u': 'u', 'e': 'e', 'o': 'o', 'ʃ': 'sh', 'ʧ': 'ch', 'ʤ': 'j', 'ŋ': 'ng', 'θ': 'th', 'ð': 'dh',
                    '¹': '', '²': '', '³': '', '⁴': '', '⁵': '', '⁶': '', '⁷': '', '⁸': '', '⁹': '' // Tones are often not written in romanization
                },

                romanize(ipaStr) {
                    return Array.from(ipaStr).map(char => this.ipaToRomanMap[char] || char).join('');
                },

                generateWord() {
                    const { consonants, vowels, syllableStructures, tones } = languageState.phonology;
                    if (consonants.length === 0 || vowels.length === 0 || syllableStructures.length === 0) return null;

                    const structure = syllableStructures[Math.floor(Math.random() * syllableStructures.length)];
                    let word = '';
                    for (const char of structure) {
                        if (char === 'C') {
                            word += consonants[Math.floor(Math.random() * consonants.length)];
                        } else if (char === 'V') {
                            word += vowels[Math.floor(Math.random() * vowels.length)];
                        }
                    }

                    let finalWord = this.applyPhonologicalRules(word);

                    if (tones.enabled) {
                        const tone = Math.floor(Math.random() * tones.count) + 1;
                        const toneMarker = String.fromCodePoint(0x2070 + tone) // Superscript numbers ¹,²,³...
                        finalWord += toneMarker;
                    }
                    return finalWord;
                },

                applyPhonologicalRules(word) {
                    let newWord = word;
                    languageState.phonology.phonologicalRules.forEach(rule => {
                        // Rule format: "A > B / C_D" (A becomes B between C and D)
                        try {
                            const [match, replacement] = rule.from.split('>').map(s => s.trim());
                            const context = rule.to;

                            let regex;
                            if (context.includes('_')) {
                                const [before, after] = context.split('_');
                                const regexBefore = before ? `(?<=${before.replace('V', `[${languageState.phonology.vowels.join('')}]`)})` : '';
                                const regexAfter = after ? `(?=${after.replace('V', `[${languageState.phonology.vowels.join('')}]`)})` : '';
                                regex = new RegExp(`${regexBefore}${match}${regexAfter}`, 'g');
                            } else {
                                regex = new RegExp(match, 'g');
                            }
                            newWord = newWord.replace(regex, replacement);
                        } catch (e) {
                            console.error("Invalid phonological rule:", rule, e);
                        }
                    });
                    return newWord;
                },

                sourceLoanwords: ['computer', 'internet', 'phone', 'radio', 'television', 'music', 'art', 'game', 'food', 'water'],

                assimilate(word) {
                    const { consonants, vowels } = languageState.phonology;
                    if (consonants.length === 0 || vowels.length === 0) return word;

                    const soundMap = {
                        'p': consonants.includes('p') ? 'p' : consonants[0], 'b': consonants.includes('b') ? 'b' : consonants.includes('p') ? 'p' : consonants[0],
                        't': consonants.includes('t') ? 't' : consonants[0], 'd': consonants.includes('d') ? 'd' : consonants.includes('t') ? 't' : consonants[0],
                        'k': consonants.includes('k') ? 'k' : consonants[0], 'g': consonants.includes('g') ? 'g' : consonants.includes('k') ? 'k' : consonants[0],
                        'f': consonants.includes('f') ? 'f' : consonants.includes('p') ? 'p' : consonants[0], 'v': consonants.includes('v') ? 'v' : consonants.includes('b') ? 'b' : consonants[0],
                        's': consonants.includes('s') ? 's' : consonants[0], 'z': consonants.includes('z') ? 'z' : consonants.includes('s') ? 's' : consonants[0],
                        'm': consonants.includes('m') ? 'm' : 'n', 'n': consonants.includes('n') ? 'n' : 'm', 'l': consonants.includes('l') ? 'l' : consonants.includes('r') ? 'r' : vowels[0],
                        'r': consonants.includes('r') ? 'r' : consonants.includes('l') ? 'l' : vowels[0], 'h': consonants.includes('h') ? 'h' : '',
                        'a': vowels.includes('a') ? 'a' : vowels[0], 'e': vowels.includes('e') ? 'e' : vowels.includes('i') ? 'i' : vowels[0],
                        'i': vowels.includes('i') ? 'i' : vowels[0], 'o': vowels.includes('o') ? 'o' : vowels.includes('u') ? 'u' : vowels[0], 'u': vowels.includes('u') ? 'u' : vowels[0],
                    };
                    return Array.from(word.toLowerCase()).map(char => soundMap[char] || '').join('');
                }
            };

            /**
             * Lexicon Module: Handles dictionary creation and management.
             */
            const Lexicon = {
                generate() {
                    const { rootCount, semanticFields, loanwords } = languageState.lexicon;
                    const newDictionary = [];
                    const pos = ['noun', 'verb', 'adjective'];

                    for (let i = 0; i < rootCount; i++) {
                        const ipa = Phonology.generateWord();
                        if (!ipa) continue;
                        const roman = Phonology.romanize(ipa);
                        const wordPos = pos[Math.floor(Math.random() * pos.length)];
                        const meaning = semanticFields[Math.floor(Math.random() * semanticFields.length)];
                        const word = { ipa: `/${ipa}/`, roman, pos: wordPos, meaning, gender: null };

                        if (word.pos === 'noun' && languageState.morphoSyntax.grammaticalGender !== 'none') {
                            const genders = languageState.morphoSyntax.grammaticalGender === 'mf' ? ['masculine', 'feminine'] : ['masculine', 'feminine', 'neuter'];
                            word.gender = genders[Math.floor(Math.random() * genders.length)];
                        }
                        newDictionary.push(word);
                    }

                    const derivedWords = [];
                    const { irregularityRate } = languageState.morphoSyntax;
                    languageState.morphoSyntax.derivationalMorphemes.forEach(morpheme => {
                        newDictionary.forEach(word => {
                            if (Math.random() < 0.3) {
                                if (Math.random() < irregularityRate) {
                                    const vowels = languageState.phonology.vowels;
                                    if (vowels.length > 0) {
                                        const baseIpa = word.ipa.slice(1, -1);
                                        const randomVowel = vowels[Math.floor(Math.random() * vowels.length)];
                                        const lastVowelIndex = Array.from(baseIpa).map((c, i) => vowels.includes(c) ? i : -1).filter(i => i !== -1).pop();
                                        if (lastVowelIndex !== undefined) {
                                            let newIpaArr = Array.from(baseIpa);
                                            newIpaArr[lastVowelIndex] = randomVowel;
                                            const newIpa = newIpaArr.join('');
                                            derivedWords.push({
                                                ipa: `/${newIpa}/`, roman: Phonology.romanize(newIpa),
                                                pos: morpheme.func, meaning: `${word.meaning} (irregular ${morpheme.func})`, gender: word.gender
                                            });
                                        }
                                    }
                                } else {
                                    const newWord = MorphoSyntax.applyDerivation(word, morpheme);
                                    if (newWord) derivedWords.push(newWord);
                                }
                            }
                        });
                    });

                    languageState.generated.dictionary = [...newDictionary, ...derivedWords];

                    if (loanwords.enabled) {
                        const loanwordCount = Math.max(1, Math.floor(rootCount * 0.05));
                        for (let i = 0; i < loanwordCount; i++) {
                            const sourceWord = Phonology.sourceLoanwords[Math.floor(Math.random() * Phonology.sourceLoanwords.length)];
                            const assimilatedIpa = Phonology.assimilate(sourceWord);
                            if (assimilatedIpa && !languageState.generated.dictionary.some(w => w.roman === assimilatedIpa)) {
                                languageState.generated.dictionary.push({
                                    ipa: `/${assimilatedIpa}/`, roman: Phonology.romanize(assimilatedIpa),
                                    pos: 'noun', meaning: `${sourceWord} (loanword)`, gender: null
                                });
                            }
                        }
                    }

                    // Generate grammatical markers based on current phonology
                    const generateGrammarMarker = () => Phonology.romanize((Phonology.generateWord() || 'a').replace(/[¹²³⁴⁵⁶⁷⁸⁹]/g, ''));
                    languageState.generated.grammarMarkers = {
                        subject: generateGrammarMarker(),
                        object: generateGrammarMarker(),
                        tense: generateGrammarMarker(),
                        agreement: { masculine: 'o', feminine: 'a', neuter: 'e' }
                    };
                }
            };

            /**
            * Morphology and Syntax Module
            */
            const MorphoSyntax = {
                applyDerivation(word, morpheme) {
                    let newIpa, newRoman;
                    const baseIpa = word.ipa.slice(1, -1);
                    if (morpheme.type === 'prefix') {
                        newIpa = morpheme.form + baseIpa;
                        newRoman = Phonology.romanize(morpheme.form) + word.roman;
                    } else { // suffix
                        newIpa = baseIpa + morpheme.form;
                        newRoman = word.roman + Phonology.romanize(morpheme.form);
                    }
                    return { ipa: `/${newIpa}/`, roman: newRoman, pos: morpheme.func, meaning: `${word.meaning} (${morpheme.func})` };
                },

                generateSentence() {
                    const { dictionary, grammarMarkers } = languageState.generated;
                    const { genderAgreement, grammaticalGender, wordOrder, caseMarking } = languageState.morphoSyntax;

                    if (!grammarMarkers) return "「語彙と文法を生成」ボタンを押して、言語を生成してください。";

                    const nouns = dictionary.filter(w => w.pos === 'noun' && w.meaning.indexOf('(') === -1);
                    const verbs = dictionary.filter(w => w.pos === 'verb' && w.meaning.indexOf('(') === -1);
                    if (nouns.length < 2 || verbs.length < 1) return "辞書に十分な名詞と動詞がありません。";

                    const subject = { ...nouns[Math.floor(Math.random() * nouns.length)] };
                    let object = { ...nouns[Math.floor(Math.random() * nouns.length)] };
                    while (object.roman === subject.roman) {
                        object = { ...nouns[Math.floor(Math.random() * nouns.length)] };
                    }
                    const verb = { ...verbs[Math.floor(Math.random() * verbs.length)] };

                    // --- Adjective & Agreement Logic ---
                    const adjectives = [{ base: "larg", meaning: "大きい" }, { base: "small", meaning: "小さい" }];
                    const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
                    let subjectAdjective = "";
                    let humanAdjective = "";

                    if (genderAgreement && grammaticalGender !== 'none' && subject.gender) {
                        humanAdjective = `${adjective.meaning}`;
                        let suffix = '';
                        if (subject.gender === 'masculine') suffix = grammarMarkers.agreement.masculine;
                        else if (subject.gender === 'feminine') suffix = grammarMarkers.agreement.feminine;
                        else if (subject.gender === 'neuter') suffix = grammarMarkers.agreement.neuter;
                        subjectAdjective = Phonology.romanize(adjective.base) + (suffix ? `-${suffix}` : '');
                    }

                    // --- Case Marking Logic ---
                    const { subject: subjectMarker, object: objectMarker, tense: verbTense } = grammarMarkers;

                    let s_final = (subjectAdjective ? subjectAdjective + " " : "") + subject.roman;
                    let o_final = object.roman;

                    if (caseMarking !== 'word-order') {
                        switch (caseMarking) {
                            case 'suffix':
                                s_final += '-' + subjectMarker;
                                o_final += '-' + objectMarker;
                                break;
                            case 'prefix':
                                s_final = subjectMarker + '-' + s_final;
                                o_final = objectMarker + '-' + o_final;
                                break;
                            case 'postposition':
                                s_final += ' ' + subjectMarker;
                                o_final += ' ' + objectMarker;
                                break;
                        }
                    }
                    const v_final = verb.roman + '-' + verbTense;

                    const components = { S: s_final, O: o_final, V: v_final };
                    const orderedSentence = wordOrder.split('').map(c => components[c]).join(' ');

                    return `${orderedSentence}. (${humanAdjective ? `その${humanAdjective}な` : 'その'}${subject.meaning}は${object.meaning}を${verb.meaning}する)`;
                }
            };

            // --- 4. UI UPDATE & EVENT HANDLING ---

            const UIManager = {
                init() {
                    this.bindEvents();
                    this.updateStateFromUI();
                    this.updateAllDisplays();
                },

                bindEvents() {
                    Object.keys(UI.controls).forEach(key => {
                        const el = UI.controls[key];
                        if (!el) return;
                        if (el.length > 0) {
                            el.forEach(item => {
                                if (item.type === 'radio') item.addEventListener('change', this.handleInputChange);
                                else if (item.dataset.preset) item.addEventListener('click', this.handlePresetClick);
                            });
                        } else if (el.nodeName) {
                            const eventType = (el.type === 'checkbox' || el.type === 'radio') ? 'change' : 'input';
                            if (el.nodeName === 'TEXTAREA' || el.nodeName === 'SELECT' || el.nodeName === 'INPUT') {
                                el.addEventListener(eventType, this.handleInputChange);
                            }
                        }
                    });

                    UI.controls.tonesEnabled.addEventListener('change', this.handleTonesToggle);
                    UI.controls.tonesCount.addEventListener('input', this.handleTonesToggle);
                    UI.controls.generateLexiconBtn.addEventListener('click', this.handleGenerateLexicon);
                    UI.controls.addPhonologyRuleBtn.addEventListener('click', () => this.addDynamicInput('phonologyRule'));
                    UI.controls.addMorphemeBtn.addEventListener('click', () => this.addDynamicInput('morpheme'));

                    UI.export.jsonBtn.addEventListener('click', this.exportJSON);
                    UI.export.csvBtn.addEventListener('click', this.exportCSV);
                },

                updateStateFromUI() {
                    languageState.phonology.consonants = UI.controls.consonants.value.trim().split(/\s+/);
                    languageState.phonology.vowels = UI.controls.vowels.value.trim().split(/\s+/);
                    languageState.phonology.syllableStructures = UI.controls.syllableStructure.value.trim().split(',').map(s => s.trim().toUpperCase());
                    languageState.phonology.tones.enabled = UI.controls.tonesEnabled.checked;
                    languageState.phonology.tones.count = parseInt(UI.controls.tonesCount.value, 10);
                    languageState.lexicon.semanticFields = UI.controls.semanticFields.value.trim().split(',');
                    languageState.lexicon.rootCount = parseInt(UI.controls.lexiconSize.value, 10);
                    languageState.lexicon.loanwords.enabled = UI.controls.loanwordsEnabled.checked;
                    languageState.morphoSyntax.wordOrder = UI.controls.wordOrder.value;
                    languageState.morphoSyntax.caseMarking = document.querySelector('input[name="case-marking"]:checked').value;
                    languageState.morphoSyntax.grammaticalGender = document.querySelector('input[name="grammatical-gender"]:checked').value;
                    languageState.morphoSyntax.genderAgreement = UI.controls.genderAgreement.checked;
                    languageState.morphoSyntax.irregularityRate = parseInt(UI.controls.irregularityRate.value, 10) / 100;

                    languageState.phonology.phonologicalRules = [];
                    document.querySelectorAll('.phonology-rule-item').forEach(item => {
                        const from = item.querySelector('.rule-from').value;
                        const to = item.querySelector('.rule-to').value;
                        if (from && to) languageState.phonology.phonologicalRules.push({ from, to });
                    });

                    languageState.morphoSyntax.derivationalMorphemes = [];
                    document.querySelectorAll('.morpheme-item').forEach(item => {
                        const type = item.querySelector('.morpheme-type').value;
                        const form = item.querySelector('.morpheme-form').value;
                        const func = item.querySelector('.morpheme-func').value;
                        if (form && func) languageState.morphoSyntax.derivationalMorphemes.push({ type, form, func });
                    });
                },

                updateAllDisplays() {
                    this.updateGrammarSummary();
                    this.updateDictionaryView();
                    this.updateExampleSentences();
                },

                updateGrammarSummary() {
                    const { phonology, morphoSyntax } = languageState;
                    const genderMap = { 'none': 'なし', 'mf': '男性/女性', 'mfn': '男性/女性/中性' };
                    const caseMap = { 'suffix': '接尾辞', 'prefix': '接頭辞', 'postposition': '後置詞', 'word-order': '語順' };
                    const toneSummary = phonology.tones.enabled ? `あり (${phonology.tones.count}種)` : 'なし';

                    UI.display.grammarSummary.innerHTML = `
                <ul>
                    <li><b>基本語順:</b> ${morphoSyntax.wordOrder}</li>
                    <li><b>格標示:</b> ${caseMap[morphoSyntax.caseMarking]}</li>
                    <li><b>文法性:</b> ${genderMap[morphoSyntax.grammaticalGender]} (${morphoSyntax.genderAgreement ? '一致あり' : '一致なし'})</li>
                    <li><b>声調:</b> ${toneSummary}</li>
                    <li><b>音節構造:</b> ${phonology.syllableStructures.join(', ')}</li>
                    <li><b>不規則性:</b> ${Math.round(morphoSyntax.irregularityRate * 100)}%</li>
                </ul>
            `;
                },

                updateDictionaryView() {
                    const tableBody = UI.display.lexiconTableBody;
                    tableBody.innerHTML = '';
                    const fragment = document.createDocumentFragment();
                    languageState.generated.dictionary.forEach(word => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                    <td>${word.ipa}</td> <td>${word.roman}</td> <td>${word.pos}</td>
                    <td>${word.meaning}</td> <td>${word.gender || '—'}</td>
                `;
                        fragment.appendChild(row);
                    });
                    tableBody.appendChild(fragment);
                },

                updateExampleSentences() {
                    UI.display.exampleSentences.innerHTML = '';
                    for (let i = 0; i < 3; i++) {
                        const p = document.createElement('p');
                        p.className = 'text-gray-300';
                        p.textContent = MorphoSyntax.generateSentence();
                        UI.display.exampleSentences.appendChild(p);
                    }
                },

                addDynamicInput(type) {
                    let div = document.createElement('div');
                    if (type === 'phonologyRule') {
                        div.className = 'phonology-rule-item flex gap-2 items-center mb-2';
                        div.innerHTML = `<input type="text" class="rule-from w-1/3" placeholder="n > m"> <span>/</span> <input type="text" class="rule-to w-1/3" placeholder="_p"> <button class="btn btn-secondary text-sm remove-btn">X</button>`;
                        UI.controls.phonologyRulesList.appendChild(div);
                    } else if (type === 'morpheme') {
                        div.className = 'morpheme-item flex gap-2 items-center mb-2';
                        div.innerHTML = `<select class="morpheme-type w-1/4"><option value="prefix">接頭辞</option><option value="suffix">接尾辞</option></select> <input type="text" class="morpheme-form w-1/4" placeholder="例: un-"> <input type="text" class="morpheme-func w-1/4" placeholder="例: 否定"> <button class="btn btn-secondary text-sm remove-btn">X</button>`;
                        UI.controls.derivationalMorphemesList.appendChild(div);
                    }
                    div.querySelector('.remove-btn').addEventListener('click', (e) => {
                        e.target.parentElement.remove();
                        this.handleInputChange(e);
                    });
                    div.querySelectorAll('input, select').forEach(el => el.addEventListener('input', this.handleInputChange));
                },

                handleInputChange(event) {
                    if (event.target.id === 'irregularity-rate') {
                        UI.controls.irregularityRateValue.textContent = `${event.target.value}%`;
                    }
                    UIManager.updateStateFromUI();
                    UIManager.updateGrammarSummary(); // Only update summary, sentences and lexicon wait for generation
                },

                handleTonesToggle() {
                    UI.controls.tonesControls.classList.toggle('hidden', !UI.controls.tonesEnabled.checked);
                    UI.controls.tonesCountValue.textContent = UI.controls.tonesCount.value;
                    UIManager.updateStateFromUI();
                    UIManager.updateGrammarSummary();
                },

                handlePresetClick(event) {
                    const preset = event.target.dataset.preset;
                    const presets = {
                        japanese: { consonants: 'p t k b d g m n s z h r j w', vowels: 'a i u e o', structure: 'CV,V,N' },
                        english: { consonants: 'p t k b d g m n l r s z ʃ ʒ h w j θ ð f v ʧ ʤ', vowels: 'i ɪ e æ u ʊ o ɔ a ɑ ə', structure: 'CVC,CCV,CV,V,VCC' },
                        spanish: { consonants: 'p t k b d g m n l r s j w f x', vowels: 'a e i o u', structure: 'CV,CVC,VC' }
                    };
                    if (presets[preset]) {
                        UI.controls.consonants.value = presets[preset].consonants;
                        UI.controls.vowels.value = presets[preset].vowels;
                        UI.controls.syllableStructure.value = presets[preset].structure;
                        UIManager.updateStateFromUI();
                        UIManager.updateGrammarSummary();
                    }
                },

                handleGenerateLexicon() {
                    UIManager.updateStateFromUI();
                    Lexicon.generate();
                    UIManager.updateAllDisplays();
                },

                download(filename, text) {
                    const element = document.createElement('a');
                    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                    element.setAttribute('download', filename);
                    element.style.display = 'none';
                    document.body.appendChild(element);
                    element.click();
                    document.body.removeChild(element);
                },

                exportJSON() {
                    const dataToExport = {
                        settings: {
                            phonology: languageState.phonology,
                            morphoSyntax: languageState.morphoSyntax,
                        },
                        generated: {
                            lexicon: languageState.generated.dictionary,
                            grammarMarkers: languageState.generated.grammarMarkers
                        }
                    };
                    UIManager.download('language.json', JSON.stringify(dataToExport, null, 2));
                },

                exportCSV() {
                    const { dictionary } = languageState.generated;
                    if (dictionary.length === 0) return;
                    let csvContent = "ipa,roman,pos,meaning,gender\n";
                    dictionary.forEach(word => {
                        const gender = word.gender || '';
                        csvContent += `"${word.ipa}","${word.roman}","${word.pos}","${word.meaning}","${gender}"\n`;
                    });
                    UIManager.download('lexicon.csv', csvContent);
                }
            };

            // --- 5. INITIALIZATION ---
            UIManager.init();
        });
    </script>

</body>

</html>
